<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Rabbit Runner</title>
  <style>
    html, body {
      height: 100%; margin: 0; background:#0b1220; color:#fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex; align-items:center; justify-content:center;
    }
    .wrap { width: 100%; max-width: 420px; padding: 16px; box-sizing: border-box; }
    h1 { margin: 0 0 8px; font-size: 20px; text-align:center; opacity:.9 }
    .hud { display:flex; justify-content:space-between; margin: 6px 0 10px; font-size:14px; opacity:.9 }
    canvas { width: 100%; height: auto; background:#0e1a33; border-radius:16px; box-shadow: 0 6px 30px rgba(0,0,0,.35); touch-action:none }
    .hint { text-align:center; margin-top:10px; font-size:12px; opacity:.75 }
    .btn { display:inline-block; background:#1e2b55; padding:8px 14px; border-radius:10px; cursor:pointer; user-select:none }
    .center { text-align:center; margin-top:10px }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<div class="wrap">
  <h1>üêá Rabbit Runner</h1>
  <div class="hud">
    <div>–°—á—ë—Ç: <span id="score">0</span></div>
    <div>–†–µ–∫–æ—Ä–¥: <span id="best">0</span></div>
  </div>
  <canvas id="game" width="320" height="480" aria-label="Rabbit Runner"></canvas>
  <div class="center"><span class="btn" id="restartBtn" hidden>–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</span></div>
  <div class="hint">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Å—Ç—Ä–µ–ª–∫–∏ / WASD ‚Ä¢ –Ω–∞ —Ç–µ–ª–µ—Ñ–æ–Ω–µ ‚Äî —Å–≤–∞–π–ø—ã</div>
</div>

<script>
/* ====== Telegram Mini App UX ====== */
const tg = window.Telegram?.WebApp;
if (tg) { try { tg.expand(); } catch(e){} }

/* ====== –ò–≥—Ä–æ–≤—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const restartBtn = document.getElementById('restartBtn');

const GRID = 16;
const COLS = Math.floor(canvas.width / GRID);
const ROWS = Math.floor(canvas.height / GRID);
const SPEED_START = 8;
const SPEED_STEP = 0.25;

/* ====== –ü–£–¢–ò –ö–ê–†–¢–ò–ù–û–ö (–ª—É—á—à–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–µ –ø—É—Ç–∏/URL) ====== */
const IMG_HEAD_SRC  = "assets/rabbit_head.png";   // –≥–æ–ª–æ–≤–∞
const IMG_BELLY_SRC = "assets/rabbit_belly.png";  // –ø—É–∑–∏–∫–æ
const IMG_TAIL_SRC  = "assets/rabbit_tail.png";   // —Ö–≤–æ—Å—Ç

/* ====== –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π ====== */
function loadImage(src){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = src;
  });
}
const assets = { head:null, belly:null, tail:null };
Promise.allSettled([
  loadImage(IMG_HEAD_SRC).then(img=> assets.head=img),
  loadImage(IMG_BELLY_SRC).then(img=> assets.belly=img),
  loadImage(IMG_TAIL_SRC).then(img=> assets.tail=img),
]).then(()=> {/* –≥–æ—Ç–æ–≤–æ */});

/* ====== –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã ====== */
function createCenteredRabbit(){
  const cx = Math.floor(COLS/2);
  const cy = Math.floor(ROWS/2);
  return {
    x: cx, y: cy,
    dx: 0, dy: 0,                   // —Å—Ç–∞—Ä—Ç –±–µ–∑ –¥–≤–∏–∂–µ–Ω–∏—è
    trail: [{ x: cx, y: cy }],
    len: 3
  };
}

let rabbit = createCenteredRabbit();
let carrot = spawnCarrot();
let score = 0, best = Number(localStorage.getItem('rr_best')||0);
let speed = SPEED_START;
let tickAccum = 0;
let last = performance.now();
let running = true;
let justTurned = false;
let autoStartTimer = null;
let growInMiddlePending = false;    // —Ä–æ—Å—Ç –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ

bestEl.textContent = best;

/* ====== –£—Ç–∏–ª–∏—Ç—ã –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ ====== */
function drawCellRect(x,y,color) {
  const px = x*GRID, py = y*GRID;
  ctx.fillStyle = color;
  ctx.fillRect(px+1, py+1, GRID-2, GRID-2);
}
function drawImageRot(img, x, y, angleRad){
  const px = x*GRID + GRID/2;
  const py = y*GRID + GRID/2;
  const size = GRID;
  ctx.save();
  ctx.translate(px, py);
  ctx.rotate(angleRad);
  ctx.drawImage(img, -size/2+1, -size/2+1, size-2, size-2);
  ctx.restore();
}
function dirToAngle(dx,dy){
  if (dx===1 && dy===0) return 0;
  if (dx===-1 && dy===0) return Math.PI;
  if (dx===0 && dy===-1) return -Math.PI/2;
  if (dx===0 && dy===1) return Math.PI/2;
  return 0;
}
function segmentDir(a,b){
  return { dx: Math.sign(b.x - a.x), dy: Math.sign(b.y - a.y) };
}

/* –ù–æ–≤–æ–µ: —É–≥–æ–ª –ø–æ–≤–æ—Ä–æ—Ç–∞ –¥–ª—è —Å—Ä–µ–¥–Ω–µ–≥–æ —Å–µ–≥–º–µ–Ω—Ç–∞ –ø–æ —Å–æ—Å–µ–¥—è–º */
function bellyAngle(prev, curr, next) {
  const dx1 = prev.x - curr.x;
  const dy1 = prev.y - curr.y;
  const dx2 = next.x - curr.x;
  const dy2 = next.y - curr.y;

  // –ø—Ä—è–º–æ–π —É—á–∞—Å—Ç–æ–∫
  if (dx1 === dx2) return Math.PI/2; // –≤–µ—Ä—Ç–∏–∫–∞–ª—å
  if (dy1 === dy2) return 0;         // –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å

  // –ø–æ–≤–æ—Ä–æ—Ç: –æ—Ä–∏–µ–Ω—Ç–∏—Ä—É–µ–º –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—é "–≤–ø–µ—Ä—ë–¥" (–∫ next)
  return dirToAngle(next.x - curr.x, next.y - curr.y);
}

/* ====== –§–æ–Ω ====== */
function drawGridBg(){
  ctx.fillStyle = '#0e1a33';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1;
  for (let x=1; x<COLS; x++){ ctx.beginPath(); ctx.moveTo(x*GRID,0); ctx.lineTo(x*GRID, canvas.height); ctx.stroke(); }
  for (let y=1; y<ROWS; y++){ ctx.beginPath(); ctx.moveTo(0,y*GRID); ctx.lineTo(canvas.width, y*GRID); ctx.stroke(); }
}

/* ====== –õ–æ–≥–∏–∫–∞ ====== */
function spawnCarrot() {
  while (true) {
    const c = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
    if (!rabbit.trail.some(t => t.x===c.x && t.y===c.y) && !(rabbit.x===c.x && rabbit.y===c.y)) return c;
  }
}

function reset() {
  if (autoStartTimer) { clearTimeout(autoStartTimer); autoStartTimer = null; }

  score = 0; scoreEl.textContent = score;
  speed = SPEED_START;
  tickAccum = 0;
  last = performance.now();
  running = true;
  justTurned = false;
  growInMiddlePending = false;

  rabbit = createCenteredRabbit();
  carrot = spawnCarrot();

  restartBtn.hidden = true;
  if (tg) { try { tg.MainButton.hide(); } catch(e){} }

  autoStartTimer = setTimeout(() => {
    if (running && rabbit.dx === 0 && rabbit.dy === 0) {
      rabbit.dx = 1; rabbit.dy = 0;
    }
    autoStartTimer = null;
  }, 500);

  drawGridBg();
  render();
}

function gameOver() {
  running = false;
  if (autoStartTimer) { clearTimeout(autoStartTimer); autoStartTimer = null; }
  restartBtn.hidden = false;
  if (tg) {
    try { tg.MainButton.setText('–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞'); tg.MainButton.show(); } catch(e){}
  }
}

function update(dt){
  if (!running) return;

  tickAccum += dt;
  const step = 1 / speed;

  while (tickAccum >= step) {
    tickAccum -= step;

    if (rabbit.dx === 0 && rabbit.dy === 0) continue;

    // –î–≤–∏–∂–µ–Ω–∏–µ –≥–æ–ª–æ–≤—ã
    rabbit.x += rabbit.dx;
    rabbit.y += rabbit.dy;

    // –ì—Ä–∞–Ω–∏—Ü—ã = –ø—Ä–æ–∏–≥—Ä—ã—à
    if (rabbit.x<0 || rabbit.y<0 || rabbit.x>=COLS || rabbit.y>=ROWS) return gameOver();

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ö–≤–æ—Å—Ç
    rabbit.trail.unshift({x:rabbit.x, y:rabbit.y});
    while (rabbit.trail.length > rabbit.len) rabbit.trail.pop();

    // –†–æ—Å—Ç –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ
    if (growInMiddlePending) {
      const mid = Math.floor(rabbit.trail.length/2);
      rabbit.trail.splice(mid, 0, { x: rabbit.trail[mid].x, y: rabbit.trail[mid].y });
      growInMiddlePending = false;
    }

    // –°–∞–º–æ–µ–¥—Å—Ç–≤–æ
    for (let i=1;i<rabbit.trail.length;i++){
      if (rabbit.trail[i].x===rabbit.x && rabbit.trail[i].y===rabbit.y) return gameOver();
    }

    // –ú–æ—Ä–∫–æ–≤–∫–∞
    if (rabbit.x===carrot.x && rabbit.y===carrot.y){
      rabbit.len++;
      score++; scoreEl.textContent = score;
      if (score>best){ best=score; bestEl.textContent=best; localStorage.setItem('rr_best', best); }
      speed += SPEED_STEP;
      carrot = spawnCarrot();
      growInMiddlePending = true;
    }

    justTurned = false;
  }
}

/* ====== –û—Ç—Ä–∏—Å–æ–≤–∫–∞ ====== */
function render(){
  drawGridBg();

  // –µ–¥–∞
  drawCellRect(carrot.x, carrot.y, '#133b18');
  ctx.font = (GRID-2) + "px serif";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText('ü•ï', carrot.x*GRID + GRID/2, carrot.y*GRID + GRID/2 + 1);

  const useSprites = assets.head && assets.belly && assets.tail;

  if (rabbit.trail.length > 0){
    // —Ö–≤–æ—Å—Ç
    if (rabbit.trail.length >= 2){
      const tailIdx = rabbit.trail.length - 1;
      const tail = rabbit.trail[tailIdx];
      const afterTail = rabbit.trail[tailIdx - 1];
      const {dx, dy} = segmentDir(tail, afterTail);
      if (useSprites) {
        drawImageRot(assets.tail, tail.x, tail.y, dirToAngle(dx,dy));
      } else {
        drawCellRect(tail.x, tail.y, '#195f78');
      }
    }

    // –ø—É–∑–∏–∫–æ (—Å—Ä–µ–¥–Ω–∏–µ —Å–µ–≥–º–µ–Ω—Ç—ã) ‚Äî –¥–æ–±–∞–≤–ª–µ–Ω –ø–æ–≤–æ—Ä–æ—Ç
    for (let i=1; i<rabbit.trail.length-1; i++){
      const prev = rabbit.trail[i-1];
      const seg  = rabbit.trail[i];
      const next = rabbit.trail[i+1];
      if (useSprites) {
        const ang = bellyAngle(prev, seg, next);
        drawImageRot(assets.belly, seg.x, seg.y, ang);
      } else {
        drawCellRect(seg.x, seg.y, '#19704f');
      }
    }

    // –≥–æ–ª–æ–≤–∞
    const head = rabbit.trail[0];
    const headAngle = dirToAngle(rabbit.dx, rabbit.dy);
    if (useSprites) {
      drawImageRot(assets.head, head.x, head.y, headAngle);
    } else {
      drawCellRect(head.x, head.y, '#1fa37c');
      ctx.font = (GRID-3) + "px serif";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText('üêá', head.x*GRID + GRID/2, head.y*GRID + GRID/2 + 1);
    }
  }
}

function loop(ts){
  const dt = (ts - last)/1000; last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ====== –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ====== */
function turn(dx,dy){
  if (!running) return;
  if (justTurned) return;
  if (dx !== 0 && rabbit.dx === -dx) return;
  if (dy !== 0 && rabbit.dy === -dy) return;

  if (autoStartTimer) { clearTimeout(autoStartTimer); autoStartTimer = null; }

  if (dx!==0 || dy!==0){
    rabbit.dx = dx; rabbit.dy = dy; justTurned = true;
  }
}
window.addEventListener('keydown', (e)=>{
  const k = e.key.toLowerCase();
  if (k==='arrowleft' || k==='a') turn(-1,0);
  else if (k==='arrowright' || k==='d') turn(1,0);
  else if (k==='arrowup' || k==='w') turn(0,-1);
  else if (k==='arrowdown' || k==='s') turn(0,1);
  else if (k==='r' && !running) reset();
});

// —Å–≤–∞–π–ø—ã
let sx=0, sy=0, swiping=false;
canvas.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; sx=t.clientX; sy=t.clientY; swiping=true; }, {passive:true});
canvas.addEventListener('touchmove', (e)=>{ if(!swiping) return; }, {passive:true});
canvas.addEventListener('touchend', (e)=>{
  if (!swiping) return; swiping=false;
  const t=(e.changedTouches||[])[0]; if(!t) return;
  const dx = t.clientX - sx, dy = t.clientY - sy;
  if (Math.abs(dx) < 10 && Math.abs(dy) < 10) return;
  if (Math.abs(dx) > Math.abs(dy)) turn(dx>0?1:-1,0); else turn(0, dy>0?1:-1);
});

restartBtn.onclick = reset;

if (tg) {
  try {
    tg.MainButton.onClick(() => { if (!running) reset(); });
  } catch (e) {}
}
</script>
</body>
</html>
